<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>YU amulet algorithm</title>
  <style>
    body { margin:0; overflow:hidden; display:flex; flex-direction:column; align-items:center; }
    #controls { position:absolute; bottom:30px; z-index:1; display: flex; gap: 10px;}
    canvas { display:block; }
    input, button { font-size:16px; padding:4px; }
    .main-ui-element{
      color: black;
      border-radius: 500px;
      border: 0;
      outline: 1px solid black;
      padding: 6px 10px;
      background-color: white;
      box-shadow: 3px 3px 5px 2px rgb(204, 204, 204)
    }
    .main-ui-element:hover{
      box-shadow: none;
    }
    #textInput{
      outline: 2px solid black;
    }

    /* Mobile style */
    @media all and (orientation:portrait) {
      #textInput{
        text-align: center;
        outline: 4px solid black;
      }
      #controls{
        flex-wrap: wrap;
        padding: 100px;
        gap: 40px;
      }
      .main-ui-element{
        font-size: 40px;
        padding: 15px 30px;
      }
      input{
        flex-basis: 100%;
      }
      button{
        flex: 1;
      }
    }
  </style>
</head>
<body>
  <div id="controls">
    <input class="main-ui-element" id="textInput" type="text" placeholder="Type text..." />
    <button class="main-ui-element" id="toggleMode">Preview</button>
    <button class="main-ui-element" id="toggleSpin">Stop Spin</button>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';

    let scene, camera, renderer, controls;
    let row = [];
    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    let modeLine = true;  // true=line mode, false=mesh/tube mode
    let currentMesh = null;
    const radius = 15;
    const silver_material = new THREE.MeshStandardMaterial({ 
        color: 0xC0C0C0,
        metalness: 1,
        roughness: 0.15,
        envMapIntensity: 1.5
    });

    // --- camera spin state ---
    let autoSpin = true;                    // spinning enabled by default
    const spinSpeed = 0.25;                 // radians per second (adjust for slower/faster)
    let spinAngle = 0;                      // current angle around Y
    let spinRadius = 0;                     // horizontal distance from origin
    const clock = new THREE.Clock();

    init();
    generateRows(radius);
    drawGuide(radius);
    animate();

    // Text innput
    document.getElementById('textInput').addEventListener('input', (e) => {
      const txt = e.target.value.toUpperCase();
      drawPattern(txt);
    });

    // Display mode button
    document.getElementById('toggleMode').addEventListener('click', () => {
      modeLine = !modeLine;
      const txt = document.getElementById('textInput').value.toUpperCase();
      document.getElementById('toggleMode').textContent = modeLine ? 'Preview' : 'Pattern';
      drawPattern(txt);
    });

    // Spin toggle button
    document.getElementById('toggleSpin').addEventListener('click', () => {
      autoSpin = !autoSpin;
      document.getElementById('toggleSpin').textContent = autoSpin ? 'Stop Spin' : 'Start Spin';
    });

    function init(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf8f8f8);

      camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(-60, 60, 0);
      camera.lookAt(0,0,0);

      // initialize spin radius/angle from the starting camera position
      spinRadius = Math.hypot(camera.position.x, camera.position.z);
      spinAngle = Math.atan2(camera.position.z, camera.position.x);

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      controls = new OrbitControls(camera, renderer.domElement);
      // Disable right-click pan controls
      controls.enablePan = false;

      // Add HDRI environment map
      const rgbeLoader = new RGBELoader();
      rgbeLoader.load('https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/blocky_photo_studio_1k.hdr', function(texture) {
          texture.mapping = THREE.EquirectangularReflectionMapping;
          scene.environment = texture;
      });

      // Enable physically correct lighting
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    function generateRows(radius){
      const lettersCount = alphabet.length;
      const letterGroup = new THREE.Group();
      letterGroup.name = 'letterGroup'

      for (let i = 0; i < lettersCount; i++) {
        const theta = (i / lettersCount) * Math.PI * 2;
        const x = Math.cos(theta) * radius;
        const z = Math.sin(theta) * radius;
        const position = new THREE.Vector3(x, 0, z);
        row.push(position);

        // Create a sprite with the letter
        const letter = alphabet[i];
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        // Enable text crisp edges
        ctx.imageSmoothingEnabled = false;
        ctx.textRendering = 'geometricPrecision';
        ctx.fillStyle = 'grey';
        ctx.font = '90px arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(letter, canvas.width / 2, canvas.height / 2);

        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture, transparent: true });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(8, 8, 1); // Adjust size as needed
        sprite.position.copy(position.clone().add(new THREE.Vector3(0, 2, 0))); // Offset above sphere
        
        letterGroup.add(sprite);
      }
      scene.add(letterGroup);
    }

    function drawGuide(radius){
      // spheres for row points
      const sphereGeom = new THREE.SphereGeometry(0.2, 12,12);
      const matTop = new THREE.MeshStandardMaterial({ 
          color: 0x000000,
          emissive: 0x808080,
          emissiveIntensity: 1.0,
          metalness: 0.9,
          roughness: 0.5
      });
      for (let i=0; i<row.length; i++){
        const sletter = new THREE.Mesh(sphereGeom, matTop);
        sletter.position.copy(row[i]);
        scene.add(sletter);
      }
    }

    function drawPattern(text){
      if(currentMesh){
        scene.remove(currentMesh);
        if(currentMesh.geometry) currentMesh.geometry.dispose();
        if(currentMesh.material) currentMesh.material.dispose();
        currentMesh = null;
      }
      if(!text) return;

      const points = [];
      for(let char of text){
        const idx = alphabet.indexOf(char);
        if(idx < 0) continue;
        const p = row[idx];
        points.push(p.clone());
      }

      if(points.length < 2) return;

      if(modeLine){
        // Switch letters on
        const letters = scene.getObjectByName('letterGroup');
        letters.visible = true;
        // Draw line
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({ color: 0x000000 });
        const line = new THREE.Line(geometry, material);
        currentMesh = line;
        scene.add(line);
      } 
      else {
        // Jewellery Preview
        // Switch letters off
        const letters = scene.getObjectByName('letterGroup');
        letters.visible = false;
        // Pattern
        const curve = new THREE.CurvePath();
        for (let i = 0; i < points.length - 1; i++) {
          curve.add(new THREE.LineCurve3(points[i], points[i + 1]));
        }
        const tabularSegments = points.length * 20;
        const radialSegments = 40;
        const thickness_radius = 1
        const tubeGeometry = new THREE.TubeGeometry(curve,tabularSegments, thickness_radius, radialSegments, false);
        const mesh = new THREE.Mesh(tubeGeometry, silver_material);
        // Torus frame
        const torusGeometry = new THREE.TorusGeometry(radius, thickness_radius, 16, 100);
        const torus = new THREE.Mesh(torusGeometry, silver_material);
        torus.rotation.x = Math.PI / 2;
        
        // Add both meshes to a group
        const group = new THREE.Group();
        group.add(torus);
        group.add(mesh);
        currentMesh = group;
        scene.add(group);
      }
    }

    function animate(){
      requestAnimationFrame(animate);

      const delta = clock.getDelta();

      if (autoSpin) {
        // update camera angle and position around Y axis while preserving camera.y
        spinAngle += spinSpeed * delta;
        const camY = camera.position.y;
        camera.position.x = spinRadius * Math.cos(spinAngle);
        camera.position.z = spinRadius * Math.sin(spinAngle);
        camera.position.y = camY;
        camera.lookAt(0, 0, 0);
      }

      controls.update();
      renderer.render(scene, camera);
    }

  </script>
</body>
</html>
