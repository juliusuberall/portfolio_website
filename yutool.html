<!DOCTYPE html>
<html>
<head>
    <title>JU - YÅª</title>
    <meta charset="UTF-8">
    <link rel="shortcut icon" type="image/png" href="images/favicon_image.png"/>
    <!---reference stylesheet in different directory--->
    <link rel="stylesheet" type="text/css" href="css/global.css">
</head>
<body>
    <div style="height: 100px; background-color: blue;"></div>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
            "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
            }
        }
    </script>

    <script type="module">

        import * as THREE from 'three'
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js'

        // Create a scene
        const scene = new THREE.Scene();

        // Create a camera and update
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight , 0.1, 1000);
        camera.position.set(0,10,0);

        //Setup renderer and set viewer in HTML
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight)
        renderer.setClearColor(0xffffff);
        document.body.appendChild(renderer.domElement);

        //Light setup
        const ambient = new THREE.AmbientLight(0xffffff,3);
        scene.add(ambient);
        const light = new THREE.DirectionalLight(0xFFFFFF, 1);
        light.position.set(-3, 5, 2);
        scene.add(light);

        // Active mesh variable
        var originalAddedGeos = [];
        var originalUsedLetters = [];

        // Create OrbitControls to enable camera rotation
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.target = new THREE.Vector3(13,0,0);
        controls.enableDamping = true;
        //Disable right mouse button movement of camera
        controls.mouseButtons = {
            LEFT: THREE.MOUSE.ROTATE,
            MIDDLE: THREE.MOUSE.DOLLY
        };

        // Create a letter to point dictionary 
        var alphabetDictionary = {};
        const alphabet = 'abcdefghijklmnopqrstuvwxyz';
        var topBottom = new THREE.Vector3(0,0,4); //start line at top
        var previousLetter; //to draw a line
        for (var i = 0; i < alphabet.length; i++) {
            var key = alphabet[i];
            var value = new THREE.Vector3(i*0.5, 0, 0);
            alphabetDictionary[key] = value;
        }

        //TESTING
        // const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
        // const cubeMaterial = new THREE.MeshPhongMaterial({ color: 0x00ff00 });
        // const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
        // scene.add(cube);


        //Write pattern from letters
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Backspace' || event.key === 'Delete') {
                if(originalAddedGeos != null && originalAddedGeos.length > 0){
                    scene.remove(originalAddedGeos[originalAddedGeos.length-1]);
                    originalAddedGeos.splice(originalAddedGeos.length-1,1);
                    originalUsedLetters.splice(originalUsedLetters.length-1,1);
                    previousLetter = originalUsedLetters[originalUsedLetters.length-1];
                    topBottom.negate();
                    return;
                }
            }
            for (var i = 0; i < alphabet.length; i++) {
                if (event.key === alphabet[i].toUpperCase() || event.key === alphabet[i].toLowerCase()) {
                    if(previousLetter != null){
                        //Create new segment
                        const tubeMaterial = new THREE.MeshPhongMaterial({ color: 0xff00ff });
                        const silverMaterial = new THREE.MeshStandardMaterial({
                            color: 0x000000,      // Base color (silver is typically gray)
                            metalness: 0.3,       // Metalness value (higher value makes it more metallic)
                            roughness: 0,       // Roughness value (lower value for smoother appearance)
                            emissive: 0x000000,   // Emissive color (no emissive color for silver)
                            envMapIntensity: 1.0, // Environment map intensity
                        });
                        const ellipseMesh = CreateEllipseMesh(
                            previousLetter,
                            event.key.toLowerCase(),
                            topBottom,
                            3,
                            50,
                            silverMaterial
                        );
                        scene.add(ellipseMesh);

                        //Cache + Housekeeping for logic
                        originalAddedGeos.push(ellipseMesh);
                        originalUsedLetters.push(alphabet[i]);
                        previousLetter = event.key.toLowerCase();
                        topBottom.negate();
            
                        controls.target = CalculateCenter(GetActiveMeshesFromScene(scene));//update orbit center
                        return;
                    }
                    else {
                        previousLetter = event.key.toLowerCase();
                        return;
                    }
                }
            }
        });

        //Basic animation + render loop for updating
        function animate(){
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();




        // Standalone implementations//////////////////////////////////////////////////////////////////
        // Function to calculate the center point of active meshes
        function CalculateCenter(inputMeshes) {
            if(inputMeshes.length > 0){
                const center = new THREE.Vector3();

                for (const mesh of inputMeshes) {
                    mesh.geometry.computeBoundingSphere();
                    center.add(mesh.geometry.boundingSphere.center.clone().applyMatrix4(mesh.matrixWorld));
                }
            
                center.divideScalar(inputMeshes.length);
                return center;
            }
            else{
                return new THREE.Vector3(0,0,0);
            }
        }

        // Filter input scene for active mesh and return array
        function GetActiveMeshesFromScene(inputscene){
            const filteredNewMeshes = [];
            inputscene.traverse((object) => {
                if (object instanceof THREE.Mesh) {
                    // Check if the object is a mesh (which typically contains a geometry)
                    const geometry = object.geometry;
                    // Ensure the geometry is not null or undefined
                    if (geometry) {
                        // Add the mesh to the array of active meshes
                        filteredNewMeshes.push(object);
                    }
                }
            });
            return filteredNewMeshes;
        }

        //Create ellipse curve and new ring segment
        function CreateEllipseMesh(previous, next, topBottom, yRadius, segmentCount, material){
            //Create ellipse curve
            const heightVector = alphabetDictionary[previous].clone().sub(alphabetDictionary[next].clone());
            const xRadius = 0.5*Math.pow((Math.pow((2*yRadius),2)+Math.pow(heightVector.length(),2)),0.5);
            const center = alphabetDictionary[next].clone().add(heightVector.divideScalar(2));//3D center of ellipse
            const curve = new THREE.EllipseCurve(0,0,heightVector.length()/2,yRadius);
            const ellipsePoints = curve.getPoints(segmentCount);
            var ellipsePoints3D = [];
            for(var i = 0; i < ellipsePoints.length; i++){
                ellipsePoints3D.push(new THREE.Vector3(ellipsePoints[i].x,ellipsePoints[i].y,0));
            }
            const curve3D = new THREE.CatmullRomCurve3(ellipsePoints3D);

            //Create Mesh of piped ellipse curve
            const tubeGeometry = new THREE.TubeGeometry(curve3D, segmentCount, 0.1, 8, true);
            const ellipseMesh = new THREE.Mesh(tubeGeometry, material);

            //Rotate and translate mesh in target position
            const xaxis = new THREE.Vector3(1,0,0);
            //Create translation plane axis and measure the angle for rotation
            const targetPlaneYaxis = alphabetDictionary[next].clone().add(topBottom.clone().negate()).clone().sub(center.clone());
            ellipseMesh.rotateY(xaxis.angleTo(targetPlaneYaxis));
            const translationMatrix = new THREE.Matrix4().makeTranslation(
                center.x,
                center.y,
                center.z
            );
            ellipseMesh.applyMatrix4(translationMatrix);
            return ellipseMesh;
        }

    </script>
</body>
</html>