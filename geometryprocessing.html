<!DOCTYPE html>
<html lang="en">
<head>
    <title>JU - UCL Geometry Processing</title>
    <link rel="shortcut icon" type="image/png" href="images/favicon_image.png"/>
    <link rel="stylesheet" type="text/css" href="css/research_project_style.css">
    <link rel="stylesheet" type="text/css" href="css/global.css">
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.1/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <div class="home-button-wrapper">
        <a href="index.html"><ion-icon class="home_button" name="grid-outline"></ion-icon></a>
    </div>
    <div id="main">
        <div id="project_headline_wrapper">
            <div id="type_date">Coursework | 2025</div>
            <div id="title">Geometry Processing</div>
            <div id="team">Acquisition and Processing of 3D Geometry taught by Prof <a href="https://geometry.cs.ucl.ac.uk/index.php" target="_blank">Niloy J. Mitra</a><br>at University College London (UCL)</div>
        </div>
        <div class="media_wrapper">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_5.jpg">
                <figcaption>Fig. 1. Spectral decomposition of an armadillo mesh into its different frequency components by computing the eigenvectors and eigenvalues of the mesh's Laplacian. Reconstruction with smallest 5, 15 and 50 basis, eigenvectors</figcaption>
            </figure>
        </div>
        <div id="abstract_wrapper">
            <div>
                <div></div>
                <div class="section_headline"></div>
            </div>
            <div>            
                <div project-name="geometryProcessing" id="quicklinks">
                </div>
                <div id="abstract">During my MSc in Computer Graphics, Vision and Imaging I was lecturing a module about Acquisition and Processing of 3D Geometry. We looked into a wide range of topics but particularly focused on meshes, iterative closest point (ICP), differential geometry, laplacians, spectral shape analysis and parameterization. The following demonstrates snippets of the tasks I accomplished.</div>
            </div>
        </div>
        <div class="section_wrapper">
            <div>
                <div class="section_headline">Halfedge Meshes</div>
            </div>
            <div>            
                <div class="section_text">A halfedge mesh is a data structure that allows for precise navigation on a mesh, such that vertices along edge loops or other patterns can be extracted. We initialise a halfedge quad mesh for a cube. Essential is to ensure that all face boundary directions are legit and against each other, resulting in all edges having an opposite edge which is reversed - the halfedge. This is crucial for navigating the topology of the halfedge mesh correctly and computing the dual.
                    <br><br>A dual polyhedron can be computed of any arbitrary manifold mesh. The topology of the dual mesh is already captured in the original mesh (fig 2). Starting with a mesh one has to collapse faces into vertices and vice-versa, computing the centroid for each face but essentially swapping face indices for vertex indices among the respective pointers within the halfedge mesh e.g. the face index for each halfedge. Crucial is to ensure the halfedge.next pointers are updated correctly, ensuring face boundary loops can be navigated correctly. If this is not the case the double dual procedure might fail due to this. 
                    <br><br>Following the bespoke method allows this transformation to run efficiently and without any list searches, which would otherwise scale exponentially with an increasing mesh size.
                    <br><br>All studies were done using the python library <div class="inline_ref" ref="r1">halfedge_mesh</div> from Carlos Rojas .</div>
            </div>
        </div>
        <div class="media_wrapper columns_2">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_1.svg">
                <figcaption>Figure 1: The data structure of a halfedge quadmesh cube. The edge directions are indicated with the rotation of the face.</figcaption>
            </figure>
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_2.svg">
                <figcaption>Figure 2:  The dual polyhedron of a cube is an octahedron and the dual of an octahedron is a cube again (top row). Meaning, the dual of a dual is the original shape but in decreased scale. The dual correspondence of vertices, edges and faces is highlighted in the bottom row. Such dual transformations can be repeated infinitely going back and forth between a dual-pair. The only limit is the numerical precision of the machine, until all vertices collapse into a single point.</figcaption>
            </figure>
        </div>
        <div class="media_wrapper">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_3.svg">
                <figcaption>Figure 3: Double dual transformation results for 4 meshes with different sizes and topologies, including: a - cube (v: 8; f: 6), b - sphere (v: 42; f: 80), c - face (v: 11’706; f: 23’408), d - flower (v: 655’362; f: 1’310’720). The images are true to scale.</figcaption>
            </figure>
        </div>
        <div class="section_wrapper">
            <div class="section_text">We can compute the volume of a triangular mesh \(M\) by determining the volumes for all individual tetrahedrons formed by the same point and a face \(F_n\). This essentially discretizes the complex shape into simpler geometries, tetrahedrons, which volume we can compute using the triple product of the face vertices. This can be thought of as computing the determinant of the 3 by 3 matrix of 3 edge-vectors \(i,j,k\) of the tetrahedron, determining the spanned volume by those in space.<br><br>However, the volume is always 6 times larger than the actual tetrahedron. Additionaly the sum of signed tetrahedra volumes is independent of the 4th <div class="inline_ref" ref="r2">vertex</div>, which allows to set such to \((0,0,0)\) and ultimately simplify the equation for the volume of any triangular and manifold mesh \(M\) with \(n\) faces to the following:</div>
            <div class="section_equation">$$M_{volume} = \frac{1}{6}\sum_{n}i_n\cdot(j_n \times k_n)$$</div>
            <div class="section_text">The double dual volume is iteratively computed 10 times for the flower example mesh (fig 3d). Given that it has ~655K vertices and ~1,3M faces which are topologically very densely arranged the volume does not change much as we consecutively compute its dual. The volume remains almost unchanged and decreases linearly on a very small scale. On the other hand our initially created cube mesh has faces and vertices that are sparsely arranged, which cause a stronger shrinking effect when collapsed into a single vertex.<br><br>The volume shrinking effect really depends on the geometry, and can either decrease very slowly or fast.</div>
        </div>
        <div class="media_wrapper">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_4.jpg">
                <figcaption>Figure 4: The volume for the iterative dual of a flower mesh (left) and low poly sphere (right).</figcaption>
            </figure>
        </div>
        <div class="section_wrapper">
            <div>
                <div class="section_headline">Iterative Closest Point</div>
            </div>
        </div>
        <div class="section_wrapper">
            <div>
                <div class="section_headline">Laplace Beltrami Operator</div>
            </div>
            <div>            
                <div class="section_text">The laplace beltrami operator is a discrete second-order differential operator describing curvature which can be thought of as the difference of a point to its local neighbourhood. For a mesh with \(x\) vertices the laplace operator is a square matrix of \(x^2\) elements, describing the topology of the mesh by capturing the connectivity of vertices.<br><br>Mean curvature \(H\) of a mesh can be defined by the vertex normals \(n\), vertices \(x\) and the uniform laplace operator \(\Delta\) as</div>
                <div class="section_equation">$$ \Delta x= -2Hn $$</div>
                <div class="section_text">and can be estimated as</div>
                <div class="section_equation">$$ H= \frac{<<\Delta x>n^{-1}>}{-2} $$</div>
                <div class="section_text">Gaussian curvature \(K\) is approximated by using the angle deficit of the angle \(\theta\) of each connected \(j\)th face at each \(i\)th vertex of the mesh.</div>
                <div class="section_equation">$$ K_i = 2\pi-\sum_j\theta_j $$</div>
                <div class="section_text">Curvature \(K_i\) is normalized using the area of the barycentric cells of all connected faces. This is defined as a 1/3 of the total area of all connected faces. The distribution of \(H\) and \(K\) seem reasonable when compared with the curvature computed on an equivalent, continuous surface using the computer aided modeling application Rhinoceros3D (fig 5). Yet the actual curvature values differ, which might be due to unnormalized values.</div>         
            </div>
        </div>
        <div class="media_wrapper full_fig">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_6.jpg">
                <figcaption>Figure 5: Mean curvature (top) Gaussian curvature (bottom) Our implementation (left) Ground truth from Rhino3D for curvature analysis on continuous surface (right).</figcaption>
            </figure>
        </div>
        <div class="media_wrapper">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_7.jpg">
                <figcaption>Figure 6: Mean curvature for three scales of remeshing, going from coarse (left) to fine (right).</figcaption>
            </figure>
        </div>
        <div class="section_wrapper">
            <div>            
                <div class="section_text">The laplace beltrami operator can be discretized in different ways. A uniform discretization weighs each neighbor in the one-ring of a vertex equally. A non-uniform, cotangent discretization weights each vertex \(v_j\) based on the edge opposing cotangents \(\alpha_{ij}\), \(\beta_{ij}\) and is normalized using the total barycentric cell area \(A_i\) as follows:</div>
                <div class="section_equation">$$ \Delta_Sf(v_i) = \frac{1}{2A_i} c(v_i) $$</div>
                <div class="section_text">with the summed cotangents \(c\) at vertex \(v_i\) :</div>
                <div class="section_equation">$$ c(v_i)= \sum_{v_j \in N(v_i)}(cot\alpha_{ij}+cot\beta_{ij})(f(v_j)-f(v_i)) $$</div>
                <div class="section_text">Since we use open meshes with a naked boundary, it is assumed that the mesh is manifold such that there can only be 2 naked edges or none for a vertex in a mesh. Additionally the cotangent weight computation is respecting naked boundary conditions, such that these edge's weight consist only of a single cotangent instead of the sum of the two opposing cotangents.
                    <br><br>The mean curvature approximation is similar between both discretizations and estimates the continuous, ground truth reasonably well (fig 7). Yet the curvature domain becomes larger, meaning min and max mean curvature are getting lower and higher using the cotangent discretizations. It indicates high and low curvature regions therefore with higher contrast in the overall distribution.
                </div>            
            </div>
        </div>
        <div class="media_wrapper">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_8.jpg">
                <figcaption>Figure 7: Mean curvature comparison for uniform (left), cotangent (middle) and Rhino3D (right).</figcaption>
            </figure>
        </div>
        <div class="section_wrapper">
            <div>            
                <div class="section_text">Performance became a critical factor when computing the spectral decomposition of a high resolution mesh like the armadillo with ~50K vertices. We overworked our implementation for the cotangent discretized Laplace-Beltrami procedure to allow for vectorized processing. We switched to a sparse solver for the eigenanalysis. Prior to optimizing our implementation, the operator computed more than 10 min, whereas afterwards only ~4 min. Initially the eigenanalysis was computed with a dense solver, however after ~30 min the machine ran out of memory. Switching to a sparse solver enabled the computation of the smallest 50 eigenvectors in 2 ½ h.</div>
                <div class="section_text">We spectrally decompose the mesh with an eigen analysis on the laplace beltrami operator, computing all eigenvectors \(e_i\). With those we can reconstruct the signal, in our case a 3D mesh, up to the \(i\)th basis with :</div>
                <div class="section_equation">$$ \hat{x}^c = \sum_i a_i^ce_i $$</div>
                <div class="section_text">In our case, the signal \(\hat{x}\) has three components for each vertex of the mesh. We determine the coefficients \(a_i\) for each basis \(e_i\) by projecting each component \(\hat{x}^c\) of the signal on each basis such that :</div>
                <div class="section_equation">$$ a_i^c = < \hat{x}^c, e_i > $$</div>
                <div class="section_text">We decomposed two meshes with ~10K vertices and reconstructed them with the smallest 10 and 100 basis functions (fig 8). The results show that depending on the used amount of smallest basis functions the reconstruction is closer to the initial mesh. The low basis functions reconstruct low frequencies and high ones high frequencies. This causes reconstructions to gradually transition from an abstract geometry back into the almost identical mesh using more basis functions.</div>
            </div>
        </div>
        <div class="media_wrapper">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_9.jpg">
                <figcaption>Figure 8: Spectral decomposition of two 10K vertices meshes. Reconstruction with smallest 10 and 100 basis, eigenvectors.</figcaption>
            </figure>
        </div>
        <div class="section_wrapper">
            <div>            
                <div class="section_text">We can also use the laplace beltrami operator to smooth geometries precisly. One way of doing so is through explicit laplcian mesh smoothing, which is defined with mesh vertices \(\boldsymbol{p}\) at smoothing iteration \(t\), step size \(\lambda\) and the Laplace-Beltrami operator \(\Delta\) as :</div>
                <div class="section_equation">$$ \boldsymbol{p}_{t+1} = \boldsymbol{p}_t + \lambda \Delta \boldsymbol{p}_t $$</div>
                <div class="section_text">This essentially averages the vertices weighted. Besides the discretization of the laplacian, the step size influences the convergence behavior, resulting either in smoothing or fracturing the geometry. The step size should be selected based on the euclidean scale of the geometry. A too large step size will cause large vertex updates and oscillating vertices. A too small step size will just result in near zero smoothing of the original shape. We tested explict laplacian mesh smoothing on three examples using the cotangent discretization (fig 9)</div>
            </div>
        </div>
        <div class="media_wrapper">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_11.jpg">
                <figcaption>Figure 9: Explicit Laplacian mesh smoothing using the cotangent discretization for a set of example geometries. All geometries have different scales and ultimately use a different smoothing step-size.</figcaption>
            </figure>
        </div>
        <div class="media_wrapper">
            <figure>
                <img src="images/JuliusUberall_geometryProcessing_10.jpg">
                <figcaption>Figure 10: Reconstruction of geometry with synthetic added noise using explicit, uniform laplacian smoothing. 5 Smoothing iterations and a step size of 1.</figcaption>
            </figure>
        </div>
        <div class="section_wrapper">
            <div>
                <div class="section_headline">References</div>
            </div>
            <div>            
                <div class="references">
                    <ol>
                        <li id="r1"><a href="https://github.com/carlosrojas/halfedge_mesh">https://github.com/carlosrojas/halfedge_mesh</a></li>
                        <li id="r2"><a href="https://www.youtube.com/watch?v=sokeN5VxBB8">https://www.youtube.com/watch?v=sokeN5VxBB8</a></li>
                    </ol>
                </div>
            </div>
        </div>
        <div class="related_wrapper">
            <div>
                <div class="section_headline">More</div>
            </div>
            <div class="project_grid_wrapper columns_4">
                <a project-name="poissonImageEditing"></a>
                <a project-name="masterthesis"></a>
                <a project-name="uberallFont"></a>
                <a project-name="meshgrowth"></a>
            </div>
        </div>
    </div>

    <!--https://ionic.io/ionicons-->
    <script type="module" src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@5.5.2/dist/ionicons/ionicons.js"></script>

    <!-- DYNAMIC JS SCRIPTS -->
    <script src="js/global.js"></script>
    <script src="js/researchProjectPage.js"></script>

    <!---CHECK-IF-EVERYTHING-LOADED_PRE-LOADING-SCREEN-ON/OFF--->
    <script>
        var loader = document.getElementById("loading-icon-wrapper");
        window.addEventListener("load",function(){loader.style.display = "none";})
    </script>
</body>
</html>